#!/bin/bash -e

set -x
export | grep 'POSTGRES\|PG'

source $OPENSHIFT_CARTRIDGE_SDK_BASH

function _pg_stop {
  pg_ctl stop -w -t 30 "$@"
}

function _is_running {
  # Can't use pg_ctl status here because it doesn't mean the db is done starting up
  psql -l -U postgres 2>&1 > /dev/null
  return $?
}

function first_run {
  setup_marker_file=$OPENSHIFT_DATA_DIR/.postgresql_setup_invocation_marker

  [ -f $setup_marker_file ]
}

function wait_for_postgres_availability {
  for i in {1..30}; do
    _is_running && return 0
    sleep 1
  done
  return 1
}

function pre_start {
  if first_run; then
    # These conf files need to override the values in the data directory AFTER it's been extracted by setup
    #  This needs to be done here because the ERB processing happens after setup
    cp $OPENSHIFT_POSTGRESQL_DIR/conf/*.conf $OPENSHIFT_POSTGRESQL_DIR/data/
    chmod 0600 $PGPASSFILE
  fi
}

function start {
  if ! _is_running; then
    echo "Starting Postgres"

    pg_ctl start
    wait_for_postgres_availability || error "Could not start Postgres" 70

    echo "Postgres started"
  else
    echo "Postgres already running"
  fi
  return 0
}

function post_start {
  setup_marker_file=$OPENSHIFT_DATA_DIR/.postgresql_setup_invocation_marker
  if first_run; then
    echo "Preparing database for first use"
    prepare_database
    rm -f $setup_marker_file
  fi
}

function stop {
  if _is_running; then
    _pg_stop -m smart ||
      _pg_stop -m fast ||
      _pg_stop -m immediate ||
      pkill postgres
    if _is_running; then
      error "Could not stop Postgres" 70
    else
      truncate -s0 $OPENSHIFT_POSTGRESQL_DB_PID
      echo "Postgres stopped"
    fi
  else
    echo "Postgres already stopped"
  fi
  return 0
}

function status {
  if _is_running; then
    client_result "Postgres is running"
  else
    client_result "Postgres is stopped"
  fi

  exit 0
}

function prepare_database {
  wait_for_postgres_availability || error "Unable to prepare Postgres" 188

  local user=$OPENSHIFT_POSTGRESQL_DB_USERNAME
  local pass=$OPENSHIFT_POSTGRESQL_DB_PASSWORD
  local db=$OPENSHIFT_APP_NAME

  # Create a user based on OPENSHIFT_POSTGRESQL_DB_USERNAME
  {
    createuser --superuser --createdb --createrole -U postgres $user
  } || error "Failed to create initial root user" 187

  # Create a database based on OPENSHIFT_APP_NAME
  {
    createdb -O $user -U postgres $db
  } || error "Failed to create database" 188

  # Set the user's password based on OPENSHIFT_POSTGRESQL_DB_PASSWORD
  {
    echo "
    ALTER USER ${user} PASSWORD '${pass}';
    " | psql -d $db -U postgres
  } || error "Failed to change password for initial root user" 187
}

function dumpfile_db {
  echo "${OPENSHIFT_DATA_DIR}/postgresql_dump_snapshot.gz"
}

function dumpfile_user {
  echo "${OPENSHIFT_DATA_DIR}/postgresql_db_username"
}

function dumpfile_dbname {
  echo "${OPENSHIFT_DATA_DIR}/postgresql_db_dbname"
}

function pre_snapshot {
  start

  echo "$OPENSHIFT_POSTGRESQL_DB_USERNAME" > $(dumpfile_user)
  echo "$OPENSHIFT_APP_NAME" > $(dumpfile_dbname)

  # Remove any statements that modify the postgres or user role
  rexp="^\s*\(DROP\|CREATE\|ALTER\)\s*ROLE\s*\(${OPENSHIFT_POSTGRSQL_DB_USERNAME}\|postgres\).*"
  pg_dumpall -c -U postgres | \
    sed "/$rexp/d;" | \
    gzip -9 > $(dumpfile_db)

  if [ ${PIPESTATUS[0]} -ne 0 ]
  then
    warning "WARNING!  Could not dump Postgres databases!  Continuing anyway"
    rm -f $(dumpfile_db)
  fi

  stop
}

function post_snapshot {
  true
}

function pre_restore {
  cleanup_dump
}

function post_restore {
  local dump_file=$(dumpfile_db)

  local new_user=$OPENSHIFT_POSTGRESQL_DB_USERNAME
  local old_user=$(< $(dumpfile_user))

  local new_db=$OPENSHIFT_APP_NAME
  local old_db=$(< $(dumpfile_dbname))

  rexp="\(DROP\|CREATE\)\s*DATABASE\s*$old_db"
  owner_rexp="\(CREATE\s*DATABASE\)\s*\(.*\)\s*OWNER\s*=\s*[^ ;]*"

  if [ -f $dump_file ]
  then
    start
    # Restore the dumped file
    zcat $dump_file | \
      sed "s#$rexp#\\1 DATABASE $new_db#g;           \
      s#$owner_rexp#\\1 \\2 OWNER = \"$new_user\"#g; \
      s#\\connect $old_db#\\connect $new_db#g;       \
      s#$old_user#$new_user#g;" |  \
      psql -U postgres -d postgres

    if [ ${PIPESTATUS[2]} -ne 0 ]
    then
      warning "Error: Could not import Postgres Database!  Continuing..."
    fi

    cleanup_dump
  else
    warning "Postgres restore attempted, but no dump found"
    warning "${dump_file} does not exist"
  fi
}

function cleanup_dump {
  dumpfiles=( $(dumpfile_db) $(dumpfile_user) $(dumpfile_dbname) )
  for file in "${dumpfiles[@]}"
  do
    rm -f $file
  done
}

case "$1" in
  start)
    pre_start
    start
    post_start
  ;;
  stop)
    stop
  ;;
  status)
    status
  ;;
  restart)
    stop
    start
  ;;
  pre-snapshot)
    pre_snapshot
  ;;
  post-snapshot)
    post_snapshot
  ;;
  pre-restore)
    pre_restore
  ;;
  post-restore)
    post_restore
  ;;
esac
